\documentclass{sigplanconf}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{multirow}
\usepackage{setspace}
\usepackage{balance}

\include{paper}
%include paper.fmt
%format (List (a) (b)) = "[" b "]_{" a "}"
%format Result_alpha = "\Varid{Result_\alpha}"
%format *> = "\mathbin{*\!\!\!>}"
%format `replaceExtension` = "\backtick{replaceExtension}"
%subst string a = "\!\text{\sf ``" a "\char34}\!"


\newcommand{\file}{\textsf}
\newcommand{\prog}{\texttt}
\newcommand{\make}{\prog{make}}

\begin{document}
\conferenceinfo{ICFP'12,} {September 27--29, 2010, Baltimore, Maryland, USA.}
\CopyrightYear{2012}
\copyrightdata{978-1-60558-794-3/10/09}

\preprintfooter{}   % 'preprint' option specified.

\title{Shake -- A Better Make}
% \subtitle{}

\authorinfo{Neil Mitchell}
           {\verb"ndmitchell@gmail.com"}

\authorinfo{Max Bolingbroke}
           {\verb"ndmitchell@gmail.com"}

\maketitle

\begin{comment}
1. State the problem
2. Say why it’s an interesting problem
3. Say what your solution achieves
4. Say what follows from your solution
\end{comment}

\begin{abstract}
Build tools, such as \make{}, are typically used for compiling source code into executables. However, most build tools fail to properly deal with generated source files, especially when the dependencies of the generated files can only be determined after the file has been generated. In many large software systems generated files are common, resulting in awkward hacks to paper over build tool inadequacies. We describe how to generalise build tools to deal properly with generated files. We have implemented our ideas as the Haskell library Shake. Shake has been used by Standard Chartered for the last three years as the basis for a complex build system involving millions of lines of code in many languages.
\end{abstract}

\category{D.3}{Software}{Programming Languages}

\terms
Languages

\keywords
build-system, compilation, Haskell

\section{Introduction}
\label{sec:introduction}

A build tool, such as \make{}, takes a set of input files, plus some rules, and produces some output files. Taking \make{} as an example, a build rule looks like:

\begin{code}
{-"\textsf{result.tar : a.txt b.txt}"-}
    {-"\textsf{tar -cf result.tar a.txt b.txt}"-}
\end{code}

\noindent This rule builds the tar archive file \file{result.tar} from the inputs \file{a.txt} and \file{b.txt}. Whenever \file{a.txt} or \file{b.txt} changes \file{result.tar} will be regenerated.

What if we want to build the file \file{result.tar} from the list of files in \file{result.files}? \make{} offers no easy way to express this pattern (there are workarounds, discussed in \S\ref{sec:make_hacks}, but none are pleasant or effective). However, using the build tool we develop in this paper, we can write:

\begin{code}
"result.tar" *> \_ -> do
    need ["result.files"]
    contents <- readFileLines "result.files"
    need contents
    system $ ["tar","-cf","result.tar"] ++ contents
\end{code}

This rule describes how to build \file{result.tar}. We depend on (|need|) the file \file{result.files}. We read \file{result.files}, and store each line in |contents| -- which is a list of the files that should go into \file{result.tar}. Next, we depend on all the files in |contents|, and finally call the \prog{tar} program specifying the files in |contents|. If the file \file{results.files} changes, or any of the files listed by \file{results.files} change, then \file{result.tar} will be rebuilt.

The key difference from \make{} (and nearly all other build tools) is that rather than specifying the dependencies of a file \textit{in advance}, we allow further dependencies to be specified \textit{after} using previous dependencies. This difference is crucial to properly handle generated files.

We have implemented our build tool as a Haskell library, named Shake, which is available online\footnote{\url{http://hackage.haskell.org/package/shake}}. Shake supports all the features of \make{}, such as minimal rebuilds (running only a subset of the rules when some subset of the inputs change), and parallelising the build (running multiple independent rules at the same time). By implementing Shake as a Haskell library we allow build system authors the full power of abstraction, using Haskell features such as modules/functions.

\subsection{Contributions}

\begin{itemize}
\item We describe the theory underlying \make{} (\S\ref{sec:theory_make}), and how to revise this theory to properly handle both generated files and rules that generate multiple outputs (\S\ref{sec:theory_shake}).
\item We describe how to extend our theory with a cache, to enable minimal rebuilds (\S\ref{sec:theory_shake_cache}).
\item We describe how to implement our build tool in Haskell, including how to present the underlying theory in a way that is practically usable (\S\ref{sec:user_view}), and how to implement it efficiently (\S\ref{sec:developer_view}). While Haskell is not essential to implement our build tool, it offers a number of advantages -- primarily making IO effects explicit and providing nice syntactic sugar.
\item We describe how additional features can be added to our build tool, taking inspiration from from compilers. We describe how to implement a Lint tool (checking all dependencies are present and the system will perform the same in parallel as in serial), a profiling tool (which rules take most time) and an analysis tool (which input file caused a rule to fire). Many of these features are directly driven by the theory.
\item We have implemented a large build system, building more than a million lines of code, producing lots of objects, multiple languages and thousands of lines of build code. We originally implemented this system in \make{}, but failed, so switched. We compare our build systems, and also give a number of guidelines to follow when using Shake.
\end{itemize}


\section{Theory}
\label{sec:theory}

In this section we first recap roughly how \make{} works, then show how Shake works. We show that Make has some theoretical limitations, which we resolve. In \S\ref{sec:user_view} we show how we can implement these ideas in a library.

\subsection{Theory of Make}
\label{sec:theory_make}

We can model \make{} as:

\begin{code}
data Rule =
    {depends :: List alpha Key
    ,creates :: Key
    ,rule :: List alpha Value -> Value
    }

make :: Rules -> List alpha Key -> List alpha Value
make rules xs = ...
\end{code}

We deliberately abstract away the entire idea of files. While Make is heavily file based, that is not an intrinsic property of Make. We use |Key| for things that can be inputs or output (think file names) and |Val| for the value associated with the |Key| (think file contents).

We can model \make{} as a function that takes a (possibly infinite) set of rules, a list of what we need to build, and builds it. We use |List alpha bullet| to denote a list which must have length |alpha|. In |make|, the number of values generated must correspond to the number of keys passed in (and in fact, each rule must be the result). A rule can be modelled as the things it depends on, the thing it creates, and the rule that takes the depended keys and produces the result keys.

The correctness condition for a set of rules is as follows. Infinite set, but their creates fields must not overlap. Must be able to sort topologically. Once you have a partial sorting you can generate a graph, and implement it by traversing the graph (the technique that \make{} adopts).

\subsection{Theory of Shake}
\label{sec:theory_shake}

Using the same terminology from the previous section, we can model our build tool as:

\begin{code}
data Rule =
    {creates :: List alpha Key
    ,rule :: Result_alpha
    }

data Result_alpha  =  Defer (List beta Key) (List beta Value -> Result_alpha)
                   |  Result (List alpha Value)

shake :: RuleSet -> List alpha Key -> List alpha Value
shake rules xs = ...
\end{code}

We have made two enhancements:

\paragraph{Dynamic Dependencies} a rule can dynamically, based on the values of dependencies, add additional dependencies. We model dynamic dependencies with the |Result_alpha| type. You can think of this type as when run returns either a list of dependencies, and blocks until those dependencies are satisfied, or returns the resulting values.

\paragraph{Multiple Results} a rule can create multiple values. Particularly running one command may result in two outputs being produced. This is usually a matter of efficiency.

The first of these is essential - it's amazing that \make{} manages to avoid it. The second is useful in some situations, but can mostly be avoided (see \S?).

\subsubsection{Correctness}

A system is correct if everything falls out. There must be a partial ordering on the |Key|'s, such that everything gets built in the right order. This property cannot be checked statically, since dependencies can be arbitrarily generated at runtime. A system is valid if it can be run to produce the outputs. If there is an ordering, the following algorithm will succeed.

Given a set of rules, and a set of keys, we define a number of terms:

\begin{itemize}
\item[interesting rules] are those which create something in the set of output keys, or who create something that an interesting rule has in it's Defer list.
\item[reduced rules] are those whose |rule| is in the |Result| state.
\item[reducible rules] are those which are in the |Defer| state, but whose immediate dependencies are all in the \textit{reduced} state.
\end{itemize}

Given a set of rules, we are finished when all the \textit{interesting} rules are \textit{reduced}. We can proceed one step by taking a rule that is both \textit{interesting} and \textit{reducible} and running the deferred function on it. If there are no rules that are both \textit{interesting} and \textit{reducible} then we are stuck, and the build system has a logical inconsistency, either because there is no rule to build something, or the build rules form a cycle.

Note that we cannot know if the build system is consistent until it has completed. In particular, there are two ways for a build system to loop. Most obviously, an \textit{interesting} and \textit{reducible} rule could have a deferred action that never terminates. Alternatively, such a rule could immediately produce the same dependencies as previously, without making progress. We assume that each rule is structured in a way that there are a finite number of steps, and each step takes a finite amount of time (in practice, it is hard to write a rule that does not obey this property).

\subsection{Cached Shake}
\label{sec:theory_shake_cache}

The standard behaviour for Shake is then to add a cache to get minimal rebuilding. Given a set of Key/Value pairs from last time, and a history trace.

You add a set of:

\begin{code}
data Cache =
    {created :: [Key]
    ,required :: [[(Key, Value)]]
    ,result :: [Value]
    }
\end{code}

Before running a rule, if we have something with an equal key 

\begin{code}
data Val
    = Doing
    | Done Value [[Key]] Status

data Status
    = Unchecked -- loaded from the cache without checking, should be checked before using
    | Equal -- loaded from the cache, checked, and computed equal
    | Different -- either was not cached, or different from the cache
\end{code}

The reason for |[[Key]]| instead of just |[Key]| is so we figure out what can be checked in parallel.

For each Key/Value pair we also store the Key/Value list that was accessed during that run. We can do this quite effectively:

\begin{code}
-- Make sure key is in the cache, and has either has Equal or Different state.
ensure key =
    if Doing then error "has a loop"
    if Equal || Different then done
    if Unchecked then
        for each key
            ensures x
            if any are not equal then bail to Missing
    if Missing then
        run rule
\end{code}

rule = if has a value in the history, then need all the keys from last time. If they are all currently equal to their historic values then move from history to current. Work by maintaining two dictionaries

\section{User View}
\label{sec:user_view}

We can implement this as the following library...

\subsection{Larger Example}

\begin{code}
    "Main.exe" *> \x -> do
        cs <- ls "*.c"
        let os = map (`replaceExtension` "obj") cs
        need os
        system $ ["gcc","-o",x] ++ os

    "*.obj" *> \x -> do
        let c = replaceExtension x "c"
        need [c]
        need =<< cIncludes c
        system ["gcc","-c",c,"-o",x]
\end{code}

\subsection{The Interface}

We have a set of rules:

\begin{code}
data Rules a = ...
    deriving (Monad, Monoid)

ruleAlways :: Make a -> Rules ()
rule :: (from -> Maybe (List alpha from, Make (List alpha to))) -> Rules ()
rule1 :: (from -> Maybe (Make to)) -> Rules ()

run :: List alpha from -> Make (List alpha to)
run1 :: from -> Make to

need :: [FilePath] -> Make ()
need xs = void $ run $ map File xs

want :: [FilePath] -> Rule ()
want xs = ruleAlways $ need xs

(*>) :: WildFilePath -> (FilePath -> Make ()) -> Rule ()
(*>) x f = rule1 $ \(File s) ->
    if s ?= x then Just $ do f s; Stamp $ getModification s else Nothing

uncached :: Make ()
uncached = need1 Uncached

rule1 $ \Uncached -> Just $ return now

shake :: ShakeOptions -> Rules () -> IO ()
\end{code}

\begin{code}

hasFlag :: String -> Bool

dotNet = do
    ruleAlways $ do
        res <- run1 $ Flag "DOTNETGEN"
        when res $
            addins <- run1 Addins
            need [dist $ x <.> "dll" | x <- addins]
\end{code}

|ruleAlways| is roughly equivalent to create a new value, add it to the todo set, and add a rule for it with the given contents.

\begin{code}
data Ls = Ls FilePath

rule :: (Eq from, Typeable from, Typeable to) => (from -> Maybe ([from], Act [to])) -> Rule

rule1 :: (Eq from, Typeable from, Typeable to) => (from -> Maybe (Act to)) -> Rule
rule1 f = rule


rule1 $ \(Ls x) -> Just $ do
    uncached
    getDirectoryContents x

data File = File FilePath


(*>) :: String -> FilePath ->


want :: Make () -> Rule ()

ruleAlways $ need [xs]


ls :: FilePath -> Make [FilePath]
ls = need1 . Ls x
\end{code}

In theory uncached just depends on the entire world - things like the current time, and things like the SHA1 of the entire system.

We use Key/Value pairs, but in Make these are mainly restricted to keys being filenames, and Value's being their contents, which are left on disk. You could imagine storing a timestamp or SHA1 in the value instead.

\begin{code}
import Development.Shake
import System.FilePath

main = shake def $ do
    want ["Main"]

    "Main" *> \_ -> do
        need ["Main.tab.o"]
        system ["gcc","-o","Main","Main.tab.o"]

    "*.o" *> \x -> do
        let c = replaceExtension x "c"
        need [c]
        headers <- cIncludes c
        need headers
        system ["gcc","-c",c,"-o",x]

    "*.tab.c" *> \x -> do
        let y = replaceExtension (dropExtension x) "y"
        need y
        system ["yacc","-o",x,y]
\end{code}


\subsection{Syntactic Sugar}

We can layer on sugar like |readFileLines| quite easily.


\section{Developer View}
\label{sec:developer_view}

\subsection{Implementation}

Easy.

\begin{code}
data State = Map Key Val

data Val
    = Done Value
    | Doing
\end{code}


\subsection{Parallelism}

Just add a lock in the Doing, use a thread pool and you are done. We always fork off all the rules in parallel, and modify the table atomically, but when checking equality we only fork threads if there is something to do (otherwise you end up with a lot of very small actions - since most just compare equalities).

\section{User Tools}
\label{sec:tools}

\subsection{Profiling}

\subsection{Analysis}

\subsection{Lint checking}

\section{Evaluation}
\label{sec:evaluation}

We have used the resulting system extensively. It replaced a huge and error prone build system. Cite the 15\% study, and say we do very little.

\subsection{Multiple Results}

GHC produces a .hi and a .o file. You can think of the .o file as depending on the entire contents of the file, and the .hi depending on only the type signatures. A single GHC invocation needs to do all the work to do both, but often it won't change the .hi file if it doesn't need to. The multiple results captures this perfectly.

In most cases you can fake the dependency - i.e. say that Foo.o depends on both Foo.hs and Foo.hi - which may work, as whenever one gets built the other will be. However, consider a process that reads a file and splits it into the even numbers and the odd numbers, avoiding writing the file back if nothing has changed.

\subsection{Transitive Dependencies}

If you have a transitive dependency you can avoid it quite easily. Consider the problem of .c files

\subsection{Rules to Follow}

Do not use ls over a universe you are changing. If you ls, it should be in the source directory, not one you create - otherwise your build system as a result of generating a file could be unsatable. Ls should return the same at the start and end of the compilation.

Put all generated files somewhere entirely separate, such as dist or |_make|. Do not comingle them.

\subsection{Lots of things generate .o files}

Then change them to have an extra extension, such as .hs.o.

\subsection{Command Line}

Just use actionAllow to filter which things they are allowed to need. You should be very careful not to miss out on things that they actually use, as you'll like get an error.


\section{Related Work}
\label{sec:related_work}

Build systems are an essential part of any large software project, yet often prove surprisingly tricky to get right. While most languages have a nice tool for building single language projects (ocamlbuild, ghc --make, Visual Studio projects), when building more complex multi-language projects, most people turn to \make{}. While there are many \make{} competitors (Scons, CMake, Ant), none have gained universal acceptance. We present Shake, a new build system based on a more powerful approach, which can do things \make{} cannot -- handling generated files properly. We have implemented Shake in Haskell, as a Haskell library, and it is used heavily -- compiling 10's of millions of lines of code per day.

A standard build system generates a dependency graph for all files, and processes them to meet the dependency constraints.


\section{Conclusions}
\label{sec:conclusions}

Shake is awesome. Any future work goes here.

\subsection*{Acknowledgements}

Thanks to Standard Chartered, where the software was developed. Thanks to Raphael Montelatici for the name Shake.


\bibliographystyle{plainnat}
\balance
\bibliography

\end{document}
