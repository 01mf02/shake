\documentclass{sigplanconf}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{multirow}
\usepackage{setspace}
\usepackage{balance}

\include{paper}
%include paper.fmt



\begin{document}
\conferenceinfo{ICFP'12,} {September 27--29, 2010, Baltimore, Maryland, USA.}
\CopyrightYear{2012}
\copyrightdata{978-1-60558-794-3/10/09}

\preprintfooter{}   % 'preprint' option specified.

\title{Shake -- A Better Make}
% \subtitle{}

\authorinfo{Neil Mitchell}
           {\verb"ndmitchell@gmail.com"}

\authorinfo{Max Bolingbroke}
           {\verb"ndmitchell@gmail.com"}

\maketitle

\begin{abstract}
Build systems are completely necessary, but universally loathed. While most languages have a nice story for building simple things (cabal install, ghc --make), there is not a good contender for general purpose make system (SCons, make, CMake). We present Shake, a theoretically sound approach which is currently used to compile millions of lines a day in many languages. The fundamental problem it solves is that of proper dependency tracking of generated files.
\end{abstract}

\category{D.3}{Software}{Programming Languages}

\terms
Languages

\keywords
Haskell, compilation, build-system

\section{Introduction}
\label{sec:introduction}

Consider a build system which tracks which dependencies.

\begin{code}
import Development.Shake
main = shake $ do
    want ["Main.exe"]

    "Main.exe" *> \x -> do
        cs <- ls "*.c"
        let os = map (`replaceExtension` "obj") cs
        need os
        system $ ["gcc","-o",x] ++ os

    "*.obj" *> \x -> do
        let c = replaceExtension x "c"
        need [c]
        need =<< cIncludes c
        system ["gcc","-c",c,"-o",x]
\end{code}

\subsection{It's Haskell}

Can use modules/functions for abstraction/separation

Can use Haskell libraries (i.e. filepath)

\subsection{It's a Make competitor}

Automatic parallelism


Minimal rebuilds

\subsection{It's better than make}

More accurate dependencies (i.e. the results of ls are tracked)

Can produce profiling reports (what took most time to build)

Can deal with generated files properly

Properly cross-platform

\section{Theory}

In this section we first recap roughly how Make works, then show how Shake works.

\subsection{Theory of Make}

\begin{code}
data Rule =
    {depends :: [Key]
    ,creates :: Key
    ,rule :: [Value] -> Value
    }

make :: RuleSet -> [Key] -> [Value]
make rules xs = ...
\end{code}

Note that each rule statically knows what files it requires before it starts. You can implement it by effectively sorting the generated rules into a graph and evaluating that graph - however, in our implementation we leave the graph implicit.

The correctness condition for a set of rules is as follows. Infinite set, but their creates fields must not overlap.

We use Key/Value pairs, but in Make these are mainly restricted to keys being filenames, and Value's being their contents, which are left on disk. You could imagine storing a timestamp or SHA1 in the value instead.

\subsection{Theory of Shake}

\begin{code}
data Rule =
    {creates :: [Key]
    ,rule :: Result
    }

data Result = Defer [Key] ([Value] -> Result)
            | Result [Value]

shake :: RuleSet -> [Key] -> [Value]
shake rules xs = ...
\end{code}

We have made two enhancements: 1) a rule can dynamically, based on the values of dependencies, change it's dependencies; 2) a rule can create multiple values. The first of these is essential - it's amazing that Make manages to avoid it. The second is useful in some situations, but far less.

\subsubsection{Dynamic Dependencies}

Consider the original example. If we add a generated file we'd still like to keep it updating the dependencies. With Make we can't do that, but Shake can.

\subsubsection{Multiple Results}

GHC produces a .hi and a .o file. You can think of the .o file as depending on the entire contents of the file, and the .hi depending on only the type signatures. A single GHC invocation needs to do all the work to do both, but often it won't change the .hi file if it doesn't need to. The multiple results captures this perfectly.

In most cases you can fake the dependency - i.e. say that Foo.o depends on both Foo.hs and Foo.hi - which may work, as whenever one gets built the other will be. However, consider a process that reads a file and splits it into the even numbers and the odd numbers, avoiding writing the file back if nothing has changed.

\subsubsection{Correctness}

A system is correct if everything falls out.

\subsection{Cached Shake}

The standard behaviour for Shake is then to add a cache to get minimal rebuilding. Given a set of:

For some rules we introduce a fake continually changing value. For things like:


\section{User View}

We can implement this as the following library...

We have a set of rules:

\begin{code}
ruleAlways :: Make a -> Rule ()
rule :: (from -> Maybe ([from], Make [to])) -> Rule ()
rule1 :: (from -> Maybe (Make to)) -> Rule ()

run :: [from] -> Make [to]
run1 :: from -> Make to

need :: [FilePath] -> Make ()
need xs = void $ run $ map File xs

want :: [FilePath] -> Rule ()
want xs = ruleAlways $ need xs

(*>) :: WildFilePath -> (FilePath -> Make ()) -> Rule ()
(*>) x f = rule1 $ \(File s) ->
    if s ?= x then Just $ do f s; Stamp $ getModification s else Nothing

uncached :: Make ()
uncached = need1 Uncached

rule1 $ \Uncached -> Just $ return now

shake :: [Rule] -> [Make ()] -> Make ()
\end{code}

\begin{code}

hasFlag :: String -> Bool

dotNet = do
    ruleAlways $ do
        res <- run1 $ Flag "DOTNETGEN"
        when res $
            addins <- run1 Addins
            need [dist $ x <.> "dll" | x <- addins]
\end{code}

|ruleAlways| is roughly equivalent to create a new value, add it to the todo set, and add a rule for it with the given contents.

\begin{code}
data Ls = Ls FilePath

rule :: (Eq from, Typeable from, Typeable to) => (from -> Maybe ([from], Act [to])) -> Rule

rule1 :: (Eq from, Typeable from, Typeable to) => (from -> Maybe (Act to)) -> Rule
rule1 f = rule 


rule1 $ \(Ls x) -> Just $ do
    uncached
    getDirectoryContents x

data File = File FilePath


(*>) :: String -> FilePath -> 


want :: Make () -> Rule ()

ruleAlways $ need [xs]


ls :: FilePath -> Make [FilePath]
ls = need1 . Ls x


    "Main.exe" *> \x -> do
        cs <- ls "*.c"
        let os = map (`replaceExtension` "obj") cs
        need os
        system $ ["gcc","-o",x] ++ os

    "*.obj" *> \x -> do
        let c = replaceExtension x "c"
        need [c]
        need =<< cIncludes c
        system ["gcc","-c",c,"-o",x]
\end{code}

In theory uncached just depends on the entire world - things like the current time, and things like the SHA1 of the entire system.

\subsection{Transitive Dependencies}

\subsection{Rules to Follow}

\subsection{Lots of things generate .o files}

Then change them to have an extra extension, such as .hs.o.

\section{Developer View}

\subsection{Implementation}

\subsection{Parallelism}

\section{User Tools}

\subsection{Profiling}

\subsection{Analysis}

\subsection{Lint checking}

\section{Evaluation}

We have used the resulting system extensively. It replaced a huge and error prone build system. Cite the 15\% study, and say we do very little.


\subsection{Conclusions}

Shake is awesome.

\subsection*{Acknowledgements}

Thanks to Standard Chartered, where the software was developed.

\bibliographystyle{plainnat}
\balance
\bibliography

\end{document}
