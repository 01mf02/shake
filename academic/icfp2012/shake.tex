\documentclass{sigplanconf}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{multirow}
\usepackage{setspace}
\usepackage{balance}

\include{paper}
%include paper.fmt
%format (List (a) (b)) = "[" b "]_{" a "}"
%format Result_alpha = "\Varid{Result_\alpha}"
%format *> = "\mathbin{*\!\!\!>}"
%format `replaceExtension` = "\backtick{replaceExtension}"

\newcommand{\make}{\texttt{make}}

\begin{document}
\conferenceinfo{ICFP'12,} {September 27--29, 2010, Baltimore, Maryland, USA.}
\CopyrightYear{2012}
\copyrightdata{978-1-60558-794-3/10/09}

\preprintfooter{}   % 'preprint' option specified.

\title{Shake -- A Better Make}
% \subtitle{}

\authorinfo{Neil Mitchell}
           {\verb"ndmitchell@gmail.com"}

\authorinfo{Max Bolingbroke}
           {\verb"ndmitchell@gmail.com"}

\maketitle

\begin{comment}
1. State the problem
2. Say why it’s an interesting problem
3. Say what your solution achieves
4. Say what follows from your solution
\end{comment}

\begin{abstract}
Build systems, such as \make{}, are typically used for compiling source code into executables. However, most build systems fail to properly deal with generated source files, especially when the dependencies of the generated files can only be determined after the file has been generated. In many large software systems generated files are common, resulting in awkward hacks to paper over build system inadequacies. We describe how to generalise build systems to deal properly with generated files. We have implemented our ideas as the Haskell library Shake. Shake has been used by Standard Chartered for the last three years as the basis for a complex build system involving millions of lines of code in many languages.
\end{abstract}

\category{D.3}{Software}{Programming Languages}

\terms
Languages

\keywords
build-system, compilation, Haskell

\section{Introduction}
\label{sec:introduction}

Need a good motivating example, which MUST rely on generated files... Could use Haskell... but much better to use C.

compile c files, they rely on header files

yacc generates c files...


checksum a list of files? create a tarball?



\begin{figure}
\begin{code}
import Development.Shake
import System.FilePath

main = shake def $ do
-- we want to produce the executable Main
    want ["Main"]

-- to produce Main.exe we list all the \texttt{*.c} files
-- change their extensions to \texttt{*.o}, ensure they are built
-- with |need|, then call \texttt{gcc} to link them.
    "Main" *> \x -> do
        cs <- ls "*.c"
        let os = map (`replaceExtension` "o") cs
        need os
        system $ ["gcc","-o",x] ++ os

-- to produce an object file, we get the \texttt{.c} file it came from,
-- ensure it is created, get the files it includes and create them,
-- then compile the file with \texttt{gcc}.
    "*.o" *> \x -> do
        let c = replaceExtension x "c"
        need [c]
        need =<< cIncludes c
        system ["gcc","-c",c,"-o",x]

    -- but be careful that you are generating grammar.c, but can't do that if you ls it too
    "grammar.c" *> \x -> do
        

\end{code}
\caption{Demo build system}
\label{fig:demo}
\end{figure}

A build system takes a set of input files, plus some rules, and produces some output files. The classic build system is \make{}.

Build systems are an essential part of any large software project, yet often prove surprisingly tricky to get right. While most languages have a nice tool for building single language projects (ocamlbuild, ghc --make, Visual Studio projects), when building more complex multi-language projects, most people turn to \make{}. While there are many \make{} competitors (Scons, CMake, Ant), none have gained universal acceptance. We present Shake, a new build system based on a more powerful approach, which can do things \make{} cannot -- handling generated files properly. We have implemented Shake in Haskell, as a Haskell library, and it is used heavily -- compiling 10's of millions of lines of code per day.

A standard build system generates a dependency graph for all files, and processes them to meet the dependency constraints.

Let us consider the problem of defining a build system that takes all the \texttt{*.c} files in a directory, compiles them all, and links them to create an executable. We have defined a new build system, Shake, in Haskell which is much better. We can implement this program in Shake, see Figure \ref{fig:demo}.

\begin{description}
\item[It's Haskell] Can use modules/functions for abstraction/separation. Can use Haskell libraries (i.e. filepath). We can use rich command line parsers.
\item[It's a Make competitor] Automatic parallelism, Minimal rebuilds.
\item[It's better than make] More accurate dependencies (i.e. the results of ls are tracked). Can produce profiling reports (what took most time to build). Can deal with generated files properly. Properly cross-platform
\end{description}

\subsection{Contributions}

\begin{itemize}
\item We describe the underlying theory we believe all Make files should be based on. In particular it allows for two inovations - generated files and also files.
\item We describe an efficient and practical implementation of our build system.
\item Our build system is practical -- it builds millions of lines an hour.
\end{itemize}

\section{Theory}

In this section we first recap roughly how Make works, then show how Shake works. We show that Make has some theoretical limitations, which we resolve. In section ? we show how we can implement these ideas in a library.

\subsection{Theory of Make}

\begin{code}
data Rule =
    {depends :: List alpha Key
    ,creates :: Key
    ,rule :: List alpha Value -> Value
    }

make :: Rules -> List alpha Key -> List alpha Value
make rules xs = ...
\end{code}

We have an infinite set of Rules, a list of what we need to build.

Note that each rule statically knows what files it requires before it starts. You can implement it by effectively sorting the generated rules into a graph and evaluating that graph - however, in our implementation we leave the graph implicit.

The correctness condition for a set of rules is as follows. Infinite set, but their creates fields must not overlap.

We use Key/Value pairs, but in Make these are mainly restricted to keys being filenames, and Value's being their contents, which are left on disk. You could imagine storing a timestamp or SHA1 in the value instead.

\subsection{Theory of Shake}

\begin{code}
data Rule =
    {creates :: List alpha Key
    ,rule :: Result_alpha
    }

data Result_alpha  =  Defer (List beta Key) (List beta Value -> Result_alpha)
                   |  Result (List alpha Value)

shake :: RuleSet -> List alpha Key -> List alpha Value
shake rules xs = ...
\end{code}

We have made two enhancements: 1) a rule can dynamically, based on the values of dependencies, change it's dependencies; 2) a rule can create multiple values. The first of these is essential - it's amazing that Make manages to avoid it. The second is useful in some situations, but far less.

\subsubsection{Dynamic Dependencies}

Consider the original example. If we add a generated file we'd still like to keep it updating the dependencies. With Make we can't do that, but Shake can.

\subsubsection{Multiple Results}

GHC produces a .hi and a .o file. You can think of the .o file as depending on the entire contents of the file, and the .hi depending on only the type signatures. A single GHC invocation needs to do all the work to do both, but often it won't change the .hi file if it doesn't need to. The multiple results captures this perfectly.

In most cases you can fake the dependency - i.e. say that Foo.o depends on both Foo.hs and Foo.hi - which may work, as whenever one gets built the other will be. However, consider a process that reads a file and splits it into the even numbers and the odd numbers, avoiding writing the file back if nothing has changed.

\subsubsection{Correctness}

A system is correct if everything falls out. There must be a partial ordering on the |Key|'s, such that everything gets built in the right order. This property cannot be checked statically, since dependencies can be arbitrarily generated at runtime.

Can be accurately run with:

\begin{code}
data State = Map Key Val

data Val
    = Done Value
    | Doing
\end{code}

If the key is in State then just use the existing Value, otherwise calculate it and put it in the list. Also keep a list of what you are currently doing, and if you hit it again you violate the ordering constraint.

\subsection{Cached Shake}

The standard behaviour for Shake is then to add a cache to get minimal rebuilding. Given a set of Key/Value pairs from last time, and a history trace:

\begin{code}
data Val
    = Doing
    | Done Value [[Key]] Status

data Status
    = Unchecked -- loaded from the cache without checking, should be checked before using
    | Equal -- loaded from the cache, checked, and computed equal
    | Different -- either was not cached, or different from the cache
\end{code}

For each Key/Value pair we also store the Key/Value list that was accessed during that run. We can do this quite effectively:

\begin{code}
-- Make sure key is in the cache, and has either has Equal or Different state.
ensure key =
    if Doing then error "has a loop"
    if Equal || Different then done
    if Unchecked then
        for each key
            ensures x
            if any are not equal then bail to Missing
    if Missing then
        run rule
\end{code}

rule = if has a value in the history, then need all the keys from last time. If they are all currently equal to their historic values then move from history to current. Work by maintaining two dictionaries 

\section{User View}

We can implement this as the following library...

We have a set of rules:

\begin{code}
data Rules a = ...
    deriving (Monad, Monoid)

ruleAlways :: Make a -> Rules ()
rule :: (from -> Maybe (List alpha from, Make (List alpha to))) -> Rules ()
rule1 :: (from -> Maybe (Make to)) -> Rules ()

run :: List alpha from -> Make (List alpha to)
run1 :: from -> Make to

need :: [FilePath] -> Make ()
need xs = void $ run $ map File xs

want :: [FilePath] -> Rule ()
want xs = ruleAlways $ need xs

(*>) :: WildFilePath -> (FilePath -> Make ()) -> Rule ()
(*>) x f = rule1 $ \(File s) ->
    if s ?= x then Just $ do f s; Stamp $ getModification s else Nothing

uncached :: Make ()
uncached = need1 Uncached

rule1 $ \Uncached -> Just $ return now

shake :: ShakeOptions -> Rules () -> IO ()
\end{code}

\begin{code}

hasFlag :: String -> Bool

dotNet = do
    ruleAlways $ do
        res <- run1 $ Flag "DOTNETGEN"
        when res $
            addins <- run1 Addins
            need [dist $ x <.> "dll" | x <- addins]
\end{code}

|ruleAlways| is roughly equivalent to create a new value, add it to the todo set, and add a rule for it with the given contents.

\begin{code}
data Ls = Ls FilePath

rule :: (Eq from, Typeable from, Typeable to) => (from -> Maybe ([from], Act [to])) -> Rule

rule1 :: (Eq from, Typeable from, Typeable to) => (from -> Maybe (Act to)) -> Rule
rule1 f = rule


rule1 $ \(Ls x) -> Just $ do
    uncached
    getDirectoryContents x

data File = File FilePath


(*>) :: String -> FilePath ->


want :: Make () -> Rule ()

ruleAlways $ need [xs]


ls :: FilePath -> Make [FilePath]
ls = need1 . Ls x


    "Main.exe" *> \x -> do
        cs <- ls "*.c"
        let os = map (`replaceExtension` "obj") cs
        need os
        system $ ["gcc","-o",x] ++ os

    "*.obj" *> \x -> do
        let c = replaceExtension x "c"
        need [c]
        need =<< cIncludes c
        system ["gcc","-c",c,"-o",x]
\end{code}

In theory uncached just depends on the entire world - things like the current time, and things like the SHA1 of the entire system.

\subsection{Syntactic Sugar}

\subsection{Transitive Dependencies}

\subsection{Rules to Follow}

\subsection{Lots of things generate .o files}

Then change them to have an extra extension, such as .hs.o.

\subsection{Command Line}

Just use actionAllow to filter which things they are allowed to need. You should be very careful not to miss out on things that they actually use, as you'll like get an error.

\section{Developer View}

\subsection{Implementation}

\subsection{Parallelism}

\section{User Tools}

\subsection{Profiling}

\subsection{Analysis}

\subsection{Lint checking}

\section{Evaluation}

We have used the resulting system extensively. It replaced a huge and error prone build system. Cite the 15\% study, and say we do very little.


\subsection{Conclusions}

Shake is awesome.

\subsection*{Acknowledgements}

Thanks to Standard Chartered, where the software was developed. Thanks to Raphael Montelatici for the name Shake.


\bibliographystyle{plainnat}
\balance
\bibliography

\end{document}
